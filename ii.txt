import os
import cv2
import numpy as np
from glob import glob
from tqdm import tqdm
import random

# ================= CONFIG ================= #
USE_LEFT = True
USE_RIGHT = True
SKIP_LEFT = False
SKIP_RIGHT = False
REG_LEFT = False
REG_RIGHT = False
AUG_LEFT = True
AUG_RIGHT = True
FINAL_SIZE = (256, 256)
APPLY_MEDIAN = False
MEDIAN_KSIZE = 3
INPUT_ROOT = "_2021-08-06-16-19-00"
OUTPUT_ROOT = "processed_dataset"
# ========================================== #

def ensure_dir(path):
    if not os.path.exists(path):
        os.makedirs(path)


def preprocess_and_save(img_path, out_path, is_rgb=True):
    img = cv2.imread(img_path, cv2.IMREAD_UNCHANGED).astype(np.float32)

    if APPLY_MEDIAN:
        nan_mask = np.isnan(img)
        if nan_mask.any():
            img_filled = np.nan_to_num(img, nan=0)

            img_median = cv2.medianBlur(img_filled.astype(np.uint8), MEDIAN_KSIZE)

            img[nan_mask] = img_median[nan_mask]

    # Resize
    img = cv2.resize(img, FINAL_SIZE, interpolation=cv2.INTER_AREA)

    if is_rgb:
        img_out = img.astype(np.uint8)
    else:
        img_out = img.astype(np.uint16)


    ensure_dir(os.path.dirname(out_path))
    cv2.imwrite(out_path, img_out)


# ============ Augmentation ============ #
def augment_and_save(img_path, out_path, is_rgb=True, num_aug=5):
    """Advanced augmentations saved to disk"""
    img = cv2.imread(img_path, cv2.IMREAD_UNCHANGED)
    h, w = img.shape[:2]

    for i in range(num_aug):
        aug_img = img.copy()

        # 1. Random rotation ±5°~15°
        angle = random.uniform(-15, 15)
        M = cv2.getRotationMatrix2D((w//2, h//2), angle, 1.0)
        aug_img = cv2.warpAffine(aug_img, M, (w,h), borderMode=cv2.BORDER_REFLECT)

        # 2. Random translation ±10%
        tx = random.uniform(-0.1*w, 0.1*w)
        ty = random.uniform(-0.1*h, 0.1*h)
        M = np.float32([[1,0,tx],[0,1,ty]])
        aug_img = cv2.warpAffine(aug_img, M, (w,h), borderMode=cv2.BORDER_REFLECT)

        # 3. Random scaling 0.9~1.1
        scale = random.uniform(0.9, 1.1)
        aug_img = cv2.resize(aug_img, None, fx=scale, fy=scale, interpolation=cv2.INTER_LINEAR)
        # Center crop/pad to FINAL_SIZE
        ch, cw = aug_img.shape[:2]
        pad_h = max(0, FINAL_SIZE[1]-ch)
        pad_w = max(0, FINAL_SIZE[0]-cw)
        aug_img = cv2.copyMakeBorder(aug_img, pad_h//2, pad_h-pad_h//2,
                                     pad_w//2, pad_w-pad_w//2, cv2.BORDER_REFLECT)
        aug_img = cv2.resize(aug_img, FINAL_SIZE, interpolation=cv2.INTER_AREA)

        # 4. Brightness/contrast adjustment (RGB only)
        if is_rgb:
            alpha = random.uniform(0.8, 1.2)  # contrast
            beta = random.uniform(-20, 20)    # brightness
            aug_img = cv2.convertScaleAbs(aug_img, alpha=alpha, beta=beta)

        # 5. Gaussian noise (Thermal only)
        if not is_rgb:
            noise = np.random.normal(0, 10, aug_img.shape).astype(np.float32)
            aug_img = np.clip(aug_img + noise, 0, 65535 if aug_img.dtype==np.uint16 else 255).astype(aug_img.dtype)

        # Save
        aug_out_path = out_path.replace(".png", f"_aug{i}.png")
        ensure_dir(os.path.dirname(aug_out_path))
        cv2.imwrite(aug_out_path, aug_img)

# ============ Dataset Processing ============ #
def process_dataset():
    for modality in ["rgb", "thr"]:
        for side in ["img_left", "img_right"]:
            if side == "img_left":
                if SKIP_LEFT or REG_LEFT:
                    continue
                do_aug = AUG_LEFT
            else:
                if SKIP_RIGHT or REG_RIGHT:
                    continue
                do_aug = AUG_RIGHT

            input_dir = os.path.join(INPUT_ROOT, modality, side)
            output_dir = os.path.join(OUTPUT_ROOT, modality, side)
            ensure_dir(output_dir)

            img_files = sorted(glob(os.path.join(input_dir, "*.png")))

            print(f"Processing {modality}/{side}: {len(img_files)} files")
            for img_path in tqdm(img_files):
                fname = os.path.basename(img_path)
                out_path = os.path.join(output_dir, fname)

                preprocess_and_save(img_path, out_path, is_rgb=(modality=="rgb"))

                if do_aug:
                    augment_and_save(out_path, out_path, is_rgb=(modality=="rgb"), num_aug=5)

if __name__ == "__main__":
    process_dataset()
